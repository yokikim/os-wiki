---

layout: page
title: 동기화(메세지 전달)
parent: 메시지-전달-시스템에서의-프로세스-간-통신,메세지-전달,메시지-전달-모델

---

### 동기화 Synchronization

프로세스 간의 통신은 send와 receive [프리미티브](프리미티브.md)에 대한 호줄에 의해 발생한다.

각 [프리미티브](프리미티브.md)를 구현하기 위한 서로 다른 설계 옵션이 있다.

메시지 전달은 [봉쇄형](봉쇄형.md) (block-ing) 이거나 [비봉쇄형](비봉쇄형.md) (nonblocking) 방식으로 전달된다.

이 두 방식은 각각 **동기식**, **비동기식**이라고도 알려져 있다(이 책 전반에 걸쳐서 다양한 운영체제 알고리즘과 관련된 동기식과 비동기식 동작을 보게 될 것이다).

- **봉쇄형 보내기**: 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 봉쇄된다.
- **비봉쇄형 보내기**: 송신하는 프로세스가 메시지를 보내고 작업을 재시작한다.
- **봉쇄형 받기:** 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다.
- **비봉쇄형 받기**: 송신하는 프로세스가 유효한 메시지 또는 널(null)을 받는다.

send( )와 receive( )의 다른 조합도 가능하다.

send( )와 receive( )가 모두 봉쇄형일 때, 우리는 송신자와 수신자 간에 랑데부(rendezvous)를 하게 된다.

봉쇄형 send( )와 receive( )를 사용한다면 생산자와 소비자 문제에 대한 해결책은 사소한 문제가 된다.

생산자는 단순히 봉쇄형 send( )를 호출하고 메시지가 수신자 또는 메일박스에 전달될 때까지 기다린다.

유사하게 소비자가 receive( )를 호출하면 메시지가 전달될 때까지 봉쇄된다. 그림 3.14와 3.15가 이 동작을 설명하고 있다.

```
message next .produced;

while (true) {
	/* produce an item in next-produced */
	send (next .produced);
}
```

```
message next .consumed;

while (true) {
	receive (next-consumed);
	/* consume the item in next.consumed */
}
```
