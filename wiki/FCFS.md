---
layout: page
title: 선입 선처리 스케줄링(FCFS)
parent: 스케줄링-알고리즘
---
가장 간단한 CPU 스케줄링 알고리즘은 **선입 선처리(FCFS)** 스케줄링 알고리즘이다.

이 방법에서는 CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.

선입 선처리 정책의 구현은 선입선출(FIFO) 큐로 쉽게 관리할 수 있다.

프로세스가 준비 큐에 진입하면, 이 프로세스의  프로세스 제어 블록(PCB)을 큐의 끝에 연결한다.

CPU가 가용 상태가 되면, 준비 큐의 앞부분에 있는 프로세스에 할당된다.

이 실행 상태의 프로세스는 이어 준비 큐에서 제거된다.

선입 선처리를 위한 코드는 작성하기 쉽고 이해하기 쉽다.

…

부정적인 측면으로 선입 선처리 정책하에서 평균대기 시간은 종종 대단히 길 수 있다.

시간 0에 도착한 다음의 프로세스 집합을 생각해 보자.

여기서 CPU 버스트 시간의 길이는 밀리초 단위이다.

![image](https://github.com/yokikim/osdinostudy_1/blob/main/os_pic/fcfs/01.png?raw=true)

프로세스들이 $P_1$, $P_2$, $P_3$ 순으로 도착하고, 선입 서너리 순으로 서비스받는다면, 다음의 **Gantt차트**에 보인 결과를 얻는다. 

Gantt 차트는 참여한 각 프로세스의 시작 시각과 종료 시각을 포함하여 특정 스케줄 기법을 도시하는 막대형 차트이다.

![image](https://github.com/yokikim/osdinostudy_1/blob/main/os_pic/fcfs/002.png?raw=true)

프로세스 $P_1$의 대기 시간은 0밀리초이며, 프로세스 $P_2$는 24밀리초이고, 프로세스 $P_3$은 27밀리초이다.

그러므로, 평균 대기 시간은 (0 + 24 + 27)/3 = 17밀리초이다.

그러나 프로세스들이 $P_2$, $P_3$, $P_1$으로 도착하면, 결과는 다음 Gnatt 차트와 같다.

![image]
(https://github.com/yokikim/osdinostudy_1/blob/main/os_pic/fcfs/003.png?raw=true)

평균대기 시간은 이제 (6+ 0 + 3)/3 = 3밀리초이다.

이러한 감소는 상당히 큰 것이다.

그러므로 선입 선처리 정책하에서 평균대기 시간은 일반적으로 최소가 아니며, 프로세스 CPU 버스트 시간이 크게 변할 경우에는 평균대기 시간도 상당히 변할 수 있다.

…

추가로 동적 상황에서 선입 선처리 스케줄링의 성능을 고려해 보자.

우리는 하나의 CPU 중심(CPU-bound) 프로세스와 많은 수의 I/O 중심 프로세스를 갖는다고 가정하자.

프로세스들이 시스템에서 진행함에 따라 다음의 시나리오가 발생할 수 있다.

> CPU중심 프로세스가 CPU를 할당받아서 점유한다.
> 
> 
> 그동안 다른 모든 프로세스는 I/O를 끝내고 준비 큐로 이동하여 CPU를 기다릴 것이다.
> 
> 프로세스들이 준비 큐에서 기다리는 동안, I/O 장치들은 쉬고 있다.
> 
> 마침내 CPU 중심 프로세스가 자신의 CPU 버스트를 끝내고 I/O 장치로 이동한다.
> 
> 모든 I/O 중심의 프로세스들은 매우 짧은 CPU 버스트를 갖고 있기 때문에, CPU 작업을 신속하게 끝내고 다시 I/O큐로 이동한다.
> 
> 이 시점에서 CPU가 쉬게 된다.
> 
> 그러면 CPU 중심 프로세스는 다시 준비 큐로 이동해 CPU를 할당받는다.
> 
> CPU 중심 프로세스가 끝날 때까지 모든 I/O 프로세스들은 다시 준비 큐에서 기다리게 된다.
> 

모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 **호위 효과**(convoy effect)라고 한다.

이 효과는 짧은 프로세스들이 먼저 처리되도록 허용될 때보다 CPU와 장치 이용률이 저하되는 결과를 낳는다.

…

선입 선처리 스케줄링 알고리즘은 비선점형이라는 것을 주의하라.

일단 CPU가 한 프로세스에 할당되면, 그 프로세스가 종료하든지 또는 I/O 처리를 요구하든지 하여 CPU를 방출할 때까지 CPU를 점유한다.

선입 선처리 알고리즘은 특히 대화형 시스템에서 문제가 되는데, 그 이유는 대화형 시스템에서는 각 프로세스가 규칙적인 간격으로 CPU의 몫을 얻는 것이 매우 중요하기 때문이다.

한 프로세스가 지나치게 오랫동안 CPU를 점유하게 허용하는 것은 손해가 클 것이다.