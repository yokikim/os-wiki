---
layout: page
title: 선점
parent: CPU-스케줄링_요약
---
[선점 및 비선점 스케줄링](선점-및-비선점-스케줄링.md)

### 요약
221p

CPU 스케줄링은 다음 네가지 상황에서 발생할 수 있다.

상황 A (비선점형)

 * 한 프로세스가 실행 상태에서 대기 상태로 전환될 때 (예를 들어, I/O 요청이나 자식 프로세스가 종료되기를 기다리기 위해 wait()를 호출할 때)
 * 프로세스가 종료할 때

상황 B (선점형)

 * 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때(예를 들어, 인터럽트가 발생할 때)
 * 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때(예를 들어, I/O의 종료 시)

A 상황의 경우 스케줄링 면에서는 선택의 여지가 없다.

실행을 위해 새로운 프로세스(준비 큐가 하나라도 존재할 경우)가 반드시 선택되어야 한다.

그러나 상황 B를 위해서는 선택의 여지가 있다.

상황 A에 대해서만 스케줄링이 발생할 경우, 우리는 이러한 스케줄링 방법을 [**비선점**](비선점.md)(nonpreemptive) 또는 **협조적**(cooperative)이라고 한다. 그렇지 않으면 그것은 **선점**(preemptive)라고 한다.

Windows, macOS, Linux 및 UNIX를 포함한 거의 모든 최신 운영체제들은 선점 스케줄링 알고리즘을 사용한다.

### 그 외 내용

불행하게도 선점 스케둘링은 데이터가 다수의 프로세스에 의해 공유될 때 경쟁조건을 초래할 수 있다.

두 프로세스가 자료를 공유하는 경우를 고려하자.

한 프로세스가 자료를 갱신하고 있는 동안 선점되어 두 번째 프로세스가 실행 가능한 상태가 될 수 있다.

이때 두 번째 프로세스가 데이터를 읽으려고 할 때, 데이터의 일관성은 이미 깨진 상태이다.

이러한 문제에 대해 [동기화 도구들](동기화-도구들_요약.md)에서 상세하게 논의할 것이다.

...

선점은 또한 운영체제 커널 설계에 영향을 준다. 시스템 콜을 처리할 동안, 커널은 한 프로세스를 위한 활동으로 바쁠 수 있다.

그러한 활동은(I/O 큐와 같은) 중요한 커널 자료 변경을 포함할 수 있다.

만일 이러한 변경 도중에 해당 프로세스가 선점되고, 커널(또는, 장치 드라이버)이 동일한 구조를 읽거나 변경할 필요가 있으면 어떤 일이 발생할까?

혼란이 계속해서 일어날 것이다.

[임계구역](임계구역.md) 문제 절에서 논의될 것처럼 운영체제 커널은 선점 또는 비선점 방식으로 설계될 수 있다.

선점형 커널에는 공유 커널 데이터 구조에 액세스 할 때 경쟁 조건을 방지하기 위해 [mutex 락](mutex-락.md)과 같은 기법이 필요하다.

대부분의 최신 운영체제는 이제 커널 모드에서 실행될 때 완전히 선점될 수 있다. 

---
[인터럽트 불능화](인터럽트-불능화.md)