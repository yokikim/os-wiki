---

layout: page
title: 인터럽트 벡터
parent: 인터럽트,인터럽트-핸들러

---

...

그러나, 인터럽트는 매우 빈번하게 발생하기 때문에 빠르게 처리되어야 한다.

필요한 속도를 제공하기 위해 인터럽트 [루틴](루틴.md)에 대한 포인터들의 *테이블*을 대신 이용할 수 있다.

이 경우 중간 루틴을 둘 필요 없이, *테이블*을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다.

일반적으로 포인터들의 *테이블*은 하위 메모리에 저장된다.(첫 100개 정도의 위치).

이들 위치에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어있다.

인터럽트가 요청되면, 인터럽트를 유발한 장치를 위한 인터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열, 즉 **인터럽트 백터**가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.

Windows나 UNIX 같은 서로 다른 운영체제가 이러한 방법으로 인터럽트를 처리한다.

...

[인터럽트 체인](인터럽트-체인.md)

---

542p

인터럽트 기법은 보통 **주소**라고 하는, 하나의 작은 정수를 받아들이는데 이 정수는 특정 인터럽트 핸들링 루틴을 선택하기 위해 사용된다.

대부분의 아키텍처에서 이 주소는 **인터럽트 벡터**라고 불리는 테이블의 오프셋으로 사용된다.

이 벡터는 인터럽트 핸들러들의 메모리 주소들을 가지고 있다.

이러한 벡터형 인터럽트 기법은 단일 인터럽트 핸들러가 서비스할 인터럽트를 결정하기 위해 모든 가능한 인터럽트의 진원지를 찾아야 할 필요를 줄인다.

그러나 컴퓨터는 인터럽트 벡터 내에 있는 주소들보다 더 많은 수의 장치가 있다.

이러한 무넺를 해결하기 위해 **인터럽트 사슬화**(chaining) 기술을 사용한다.

인터럽트 사슬화에서는 인터럽트 벡터의 각 원소가 여러 인터럽트 핸들러들로 이루어진 리스트의 헤더를 가리키고 있다.

인터럽트가 일어났을 때는, 해당 핸들러가 찾아질때까지 리스트 상의 핸들러들을 하나씩 검사하게 된다.

이 구조는 거대한 인터럽트 테이블을 둘지, 아니면 인터럽트 핸들러를 찾아 수행할 때까지의 효율을 다소 희생할지에 관한 절충안이다.

