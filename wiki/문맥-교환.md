---

layout: page
title: 문맥 교환
parent: 프로세스_요약

---



126p

[인터럽트](인터럽트.md)는 운영체제가 CPU 코어를 현재 작업에서 뺏어 내어 커널 루틴을 실행할 수 있게 한다.

이러한 연산을 범용 시스템에서는 자주 발생한다.

인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다.

이는 결국 프로세스를 중단했다가 재개하는 작업이다.

문맥은 프로세스의 [PCB](프로세스-제어-블록.md)에 표현된다.

문맥은 CPU  [레지스터](레지스터.md)의 값, [프로세스](프로세스.md) 상태, 메모리 관리 정보 등을 포함한다.

일반적으로 커널 모드이건 사용자 모드이건 CPU의 현재 상태를 저장하는 작업을 수행하고(state save)

나중에 연산을 재개하기 위하여 상태 복구 작업을 수행한다(state restore).
...

CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요하다.

이 작업은 문맥 교환(context switch)이라고 한다.

문맥 교환이 일어나면, 커널은 과거 프로세스의 문맥을 [PCB](프로세스-제어-블록.md)에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구한다.

문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 문맥 교환시간은 순수한 오버헤드이다.

교환 속도는 메모리의 속도, 반드시 복사되어야 하는 레지스터의 수, 특수 명령어(모든 레지스터를 하나의 명령어로 보관하고 적재하는 것 같은)의 존재에 좌우되므로, 기계마다 다르다.

전형적인 속도는 수 마이크로초까지 분포되어 있다.

...

문맥 교환 시간은 하드웨어의 자원에 크게 좌우된다.

예를 들어 일부 처리기들은 여러 개의 레지스터 집합을 제공한다.

문맥 교환은 단순히 현행 레지스터 집합에 대한 포인터를 변경하는 것을 포함한다.

물론, 레지스터 집합들보다도 활성 프로세스들이 더 많다면, 시스템은 전처럼 레지스터 자료를 메모리로 또는 메모리에서 복사해야 한다.

또한 운영체제가 복잡할수록, 문맥 교환 시 해야 할 작업의 양이 더 많아진다.

복잡한 고급 메모리 관리 기법을 사용하면 문맥 교환 시 더 많은 자료들을 교환해야 한다.

얘를 들어, 문맥 교환 시 현재 프로세스의 주고 공간은 다음 태스크의 공간이 사용 준비되는 동안 반드시 보존되어야 한다.

주소 공간이 어떤식으로 보존되고, 보존하기 위해 수행해야 할 작업의 양은 운영체제의 메모리 관리 기법에 따라 달라진다.

![image](https://user-images.githubusercontent.com/116250393/212076217-0b44125e-883a-4f41-a23e-b572d930cfb2.png)
