---

layout: page
title: Linux 스레드
parent: 태스크

---




214p

3장에서 설명한 것처럼 프로세스를 복제하는 기능을 가진 fork() 시스템 콜을 제공한다.

Linux는 clone() 시스템 콜을 이용하여 스레드를 구별하지 않는다.

사실 Linux는 프로그램 내의 제어 흐름을 나타내기 위하여 *프로세스*나 *스레드*보다 태스크라는 용어를 사용한다.

### 부모 태스크와 자식 태스크

clone()이 호출될 때 부모와 자식 태스크가 자료구조를 얼마나 공유할지 결정하는 플래그의 집합이 전달된다.

그중 일부 플래그들이 다음과 같이 나열되어 있다.

![image](https://user-images.githubusercontent.com/116250393/213805513-0c7a6907-cd37-4868-b7c9-2dc2871013c1.png)

예를 들어, clone()이 CLONE_FS, CLONE_VM, CLONE_SIGHAND와 CLONE_FILES를 전달받았다고 가정하자.

부모 태스크와 자식 태스크는 같은 파일 시스템 정보(현재 작업 디렉터리 등), 같은 메모리 공간, 같은 신호 처리기와 같은 열린 파일의 집합을 공유하게 된다.

이러한 식으로 clone()을 사용하는 것은 부모 태스크가 자식 태스크와 거의 모든 자원을 공유하기 때문에 이 장에서 설명한 스레드를 생성하는 것과 같은 결과가 된다.

그러나 아무 플래그 없이 clone()이 호출되면 공유는 일어나지 않게 되고 fork() 시스템 콜이 제공하는 기능과 유사한 기능성을 제공한다.

### 자료구조와 포인터

Linux 커널이 태스크를 표현하는 방식 때문에 다양한 공유 수준이 가능하다.

시스템의 태스크마다 고유한 커널 자료구조가(struct task_struct) 존재한다.

이 자료 구조는 태스크의 데이터를 저장하는 것이 아니라 데이터가 저장된 다른 자료구조를 가리키는 포인터를 포함한다.

다른 자료구조에는 열린 파일의 리스트를 나타내는 자료구조, 신호 처리 정보 및 가상 메모리 등이 있다.

fork()가 호출되면 부모 프로세스의 관련된 자료구조를 복사함으로써 새로운 태스크를 생성한다.

clone() 시스템 콜을 호출하여 새로운 태스크를 생성할 수도 있다.

그러나 모든 데이터를 복사하는 것이 아니라 clone()에게 전달된 플래그에 따라 부모 태스크의 자료구조를 가리키게 된다.

### 리눅스 컨테이너

마지막으로, clone() 시스템 콜의 융통성은 컨테이너 개념으로 확장될 수 있다.

컨테이너 개면은 1장에서 소개된 가상화 주제이다.

1장에서 컨테이너는 운영체제가 제공하는 가상화 기법으로 하나의 Linux 커널 아래 서로 격리되어 실행되는 여러 개의 Linux 시스템(컨테이너)을 생성하는 것을 가능하게 한다.

clone()에 전달된 특정 플래그가 부모와 자직 태스크 사이의 정보 공유량에 따라 프로세스처럼 작동하는 태스크를 생성하느냐 또는 스레드를 생성하느냐를 구분하는 것처럼, Linux 컨테이너를 생성하도록 clone()에 전달할 수 있는 다른 플래그가 있다.
