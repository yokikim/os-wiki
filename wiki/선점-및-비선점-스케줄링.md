---
title: 선점 및 비선점 스케줄링
parent: CPU-스케줄링,CPU-스케줄링_요약
layout: page
---
CPU 스케줄링 결정은 다음의 네 가지 상황에서 발생할 수 있다.

1. 한 프로세스가 실행 상태에서 대기 상태로 전환될 때(예를 들어, I/O 요청이나 자식 프로세스가 종료되기를 기다리기 위해 `wait( )` 를 호출할때)
2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때(예를 들어, 인터럽트가 발생할 때)
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때(예를 들어, I/O의 종료 시)
4. 프로세스가 종료할 때

상황 1과 4의 경우, 스케줄링 면에서는 선택의 여지가 없다.

실행을 위해 새로운 프로세스(준비 큐에 하나라도 존재할 경우)가 반드시 선택되어야 한다.

그러나 상황 2와 3을 위해서는 선택의 여지가 있다.

…

상황 1과 4에서만 스케줄링이 발생할 경우, 우리는 이러한 스케줄링 방법을 **비선점**(nonpreemptive) 또는 **협조적**(cooperative)이라고 한다.

그렇지 않으면, 그것은 선점(preemptive)이라고 한다.

비선점 스케줄링하에서는, 일단 CPU가 한 프로세스에 할당 되면 프로세스가 종료하든지, 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유한다.

Windows, macOS, Linux 및 UNIX를 포함한 거의 모든 최신 운영체제들은 선점 스케줄링 알고리즘을 사용한다.

…

불행하게도 선점 스케줄링은 데이터가 다수의 프로세스에 의해 공유될 때 경쟁조건을 초래할 수 있다.

두 프로세스가 자료를 공유하는 경우를 고려하자.

한 프로세스가 자료를 갱신하고 있는 동안 선점되어 두 번째 프로세스가 실행 가능한 싱태가 될 수 있다.

이때 두 번째 프로세스가 데이터를 읽으려고 할 떄, 데이터의 일관성은 이미 깨진 상태이다.

…

선점은 또한 운영체제 커널 설계에 영향을 준다.

시스템 콜을 처리할 동안, 커널은 한 프로세스를 위한 활동으로 바쁠 수 있다.

그러한 활동은(I/O 큐와 같은) 중요한 커널 자료 변경을 포함할 수 있다.

만일 이러한 변경 도중에 해당 프로세스가 선점되고, 커널(또는, 장치 드라이버)이 동일한 구조를 읽거나 변경할 필요가 있으면 어떤 일이 발생할까?

혼란이 계속해서 일어날 것이다.

임계구역 문제에서 논의될 것처럼 운영체제 커널은 선점 또는 비선점 방식으로 설계될 수 있다.

비선점형 커널은 문맥 교환을 하기 전에 시스템 콜이 완료되거나 입출력 완료를 기다리며 프로세스가 봉쇄되기를 기다린다.

커널 자료구조가 비일관적인 상태에 있을 때 커널이 해당 프로세스를 선점하지 않기 때문에, 이러한 방법은 커널 구조를 단순하게 만든다.

불행하게도 이러한 커널 실행 모델은 주어진 시간 안에 태스크의 실행이 완료되어야 하는 실시간 컴퓨팅을 지원하기에는 좋은 모델이 아니다.

선점형 커널에는 공유 커널 데이터 구조에 액세스 할 때 경쟁조건을 방지하기 위해 mutex 락과 같은 기법이 필요하다.

대부분의 최신 운영체제는 이제 커널 모드에서 실행될 때 완전히 선점될 수 있다.

…

- 인터럽트 불능화
    
    정의에 의하면 인터럽트는 어느 시점에서건 일어날 수 있고, 커널에 의해서 항상 무시될 수는 없기 때문에, 인터럽트에 의해서 영향을 받는 코드 부분은 반드시 동시 사용으로부터 보호되어야 한다.
    
    운영체제는 거의 항상 인터럽트를 받아들일 필요가 있는데, 그렇지 않으면 입력을 잃어버리거나 또는 출력이 겹쳐 쓰일 수 있다.
    
    따라서 이러한 코드 부분은 다수 프로세스가 병행으로 접근할 수 없도록 그 진입점에서 인터럽트를 불능화하고, 출구에서 인터럽트를 다시 가능화한다.
    
    인터럽트 불능화는 자주 발생해서는 안 되고 아주 적은 수의 명령어들만 포함되어야 한다.
