---

layout: page
title: 메인 메모리 요약

---



- 메모리는 최신 컴퓨터 시스템 작동의 중심이며 각각 고유한 주소를 가진 큰 바이트배열로 구성된다.
- 각 프로세스에 주소 공간을 할당하는 한 가지 방법은 기준 및 [상한 레지스터](상한-레지스터.md)를 사용하는 것이다. [기준 레지스터](기준-레지스터.md)는 가장 작은 유효한 물리 메모리 주소를 저장하며 상한은 메모리 범위의 크기를 지정한다.
- 심볼릭 주소 참조를 실제 물리 주소에 바인딩하는 작업은 (1) 컴파일, (2) 적재 또는 (3) 실행시간에 발생할 수 있다.
- [CPU](CPU.md)가 생성한 주소를 논리 주소라고 하며 [메모리 관리 장치](메모리-관리-장치.md) ([MMU](MMU.md))가 메모리의 물리 주소로 변환한다.
- 메모리를 할당하는 한 가지 방법은 다양한 크기의 연속 메모리 파티션을 할당하는 것이다. 이러한 파티션은 세 가지 가능한 전략, 즉 (1) 최초 적합, (2) 최적 적합 및 (3) 최악 적합에 따라 할당될 수 있다.
- 최신 운영체제는 페이징을 시용하여 메모리를 관리한다. 이 과정에서 물리 메모리는 프레임이라는 고정 크기 블록으로, 논리 메모리는 페이지라는 같은 크기의 블록으로 나뉜다.
- 페이징을 사용하는 경우 논리 주소는 페이지 번호와 페이지 오프셋이라는 두 부분으로 나뉜다. 페이지 번호는 페이지를 저장하는 물리 메모리 프레임을 유지하는 프로 세스별 페이지 테이블에 대한 인덱스 역할을 한다. 오프셋은 참조되는 프레임의 특정 위치이다.
- TLB (translation look-aside buffer)는 페이지 테이블의 하드웨어 캐시이다. 각 TLB 항목에는 페이지 번호와 상응하는 프레임을 저장한다.
- 페이징 시스템의 주소 변환에 TLB를 사용하려면 논리 주소에서 페이지 번호를 가져 와서 해당 페이지의 프레임이 TLB에 있는지 확인한다. 만약 그렇다면, 프레임은 TLB로부터 얻어진다. TLB에 프레임이 없으면 페이지 테이블에서 찾아야 한다.
- 계층적 페이징은 논리 주소를 여러 부분으로 나누고 각 단계는 서로 다른 페이지 테이블 수준을 나타낸다. 주소가 32비트 이상으로 확장됨에 따라 계층 레벨 수가 커질 수 있다. 이 문제를 해결하는 두 가지 전략은 해시 페이지 테이블과 역 페이지 테이블이다.
- 스와핑을 통해 시스템은 프로세스에 속하는 페이지를 디스크로 이동하여 다중 프로 그래밍 정도를 높일 수 있다.
- Intel 32비트 아키텍처에는 두 가지 수준의 페이지 테이블이 있으며 4 KB 또는 4MB 페이지 크기를 지원한다. 이 아키텍처는 또한 페이지 주소 확장을 지원하므로 32비트 프로세서가 4 GB보다 큰 물리적 주소 공간에 액세스 할 수 있다. X86-64 및 ARMv9 아키텍처는 계층적 페이징을 사용하는 64비트 아키텍처이다.