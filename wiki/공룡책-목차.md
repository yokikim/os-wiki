---
title: 공룡책 목차
layout: page
---
# 개관

## 서론

### 1.1	운영체제가 할 일 4

1.1.1 사용자 관점

1.1.2 시스템 관점

1.1.3 운영체제의 정의

왜 운영체제를 공부하는가?

### 1.2	컴퓨터 시스템의 구성 7

1.2.1 인터럽트

1.2.1.1 개요

1.2.1.2 구현

1.2.2 저장장치 구조

저장장치 정의와 표기

1.2.3 입출력 구조

### 1.3	컴퓨터 시스템 구조 16

1.3.1 단일 처리기 시스템

1.3.2 다중 처리기 시스템

컴퓨터 시스템 구성요소의 정의

1.3.3 클러스터형 시스템

PC 마더보드

HADOOP

### 1.4	운영체제의 작동 23

1.4.1 다중 프로그래밍과 다중 태스킹

1.4.2 이중—모드와 다중모드 운용

1.4.3 타이머

Linux 타이머

### 1.5	자원관리 28

1.5.1 프로세스 관리

1.5.2 메모리 관리

1.5.3 파일 시스템 관리

1.5.4 대용량 저장장치 관리

1.5.5 캐시 관리

1.5.6 입출력 시스템 관리

### 1.6	보안과보호 35

### 1.7	가상화 36

### 1.8	분산시스템 38

### 1.9	커널 자료구조 39

1.9.1 리스트, 스택 및 큐

1.9.2 트리

1.9.3 해시 함수와 맵

1.9.4 비트맵

Linux 커널 자료구조

### 1.10	계산 환경 43

1.10.1 전통적 계산

1.10.2 모바일 컴퓨팅

1.10.3 클라이언트 서버 컴퓨팅

1.10.4 피어 간 계산

1.10.5 클라우드 컴퓨팅

1.10.6 실시간 내장형 시스템

### 1.11 무료 및 공개 소스운영체제 50

1.11.1 역사

1.11.2 무료 운영체제

1.11.3 GNU/Linux

1.11.4 BSD Unix

1.11.5 Solaris

1.11.6 학습 도구로서 공개 소스 시스템

운영체제의 학습

## 운영체제의 구조

### 2.1	운영체제서비스 62

### 2.2	시용자와운영체제 인터페이스 64

2.2.1 명령 인터프리터

2.2.2 그래픽 기반 사용자 인터페이스

2.2.3 터치스크린 인터페이스

2.2.4 인터페이스의 선택

### 2.3	시스템콜 68

2.3.1 예제

2.3.2 응용 프로그래밍 인터페이스

표준 API의 예

2.3.3 시스템 콜의 유형

Windows와 UNIX 시스템 콜의 예

표준 C 라이브러리

2.3.3.1 프로세스 제어

2.3.3.2 파일 관리

2.3.3.3 장치 관리

2.3.3.4 정보 유지 관리

2.3.3.5 통신

2.3.3.6 보호

### 2.4 시스템 서비스 82

### 2.5 링커와로더 84

ELF 형식

### 2.6	응용 프로그램이 운영체제마다 다른 이유 86

### 2.7	운영체제 설계 및 구현 88

2.7.1 설계 목표

2.7.2 기법과 정책

2.7.3 구현

### 2.8 운영체제구조 90

2.8.1 모놀리식 구조

2.8.2 계층적 접근

2.8.3 마이크로 커널

2.8.4 모듈

2.8.5 하이브리드 시스템

2.8.5.1 macOS와 iOS

2.8.5.2 Android

### 2.9	운영체제 빌딩과 부팅 100

Linux를 위한 Windows 서브시스템

2.9.1 운영체제 생성

2.9.2 시스템 부트

### 2.10	운영체제 디버깅 105

2.10.1 장애 분석

2.10.2 성능 관찰 및 조정

2.10.2.1 카운터

Kernighan’s 법칙

2.10.3 추적

2.10.4 BCC

# 프로세스 관리

### 프로세스

### 3.1	프로세스 개념 118

3.1.1 프로세스

C 프로그램의 메모리 배치

3.1.2 프로세스의 상태

3.1.3 프로세스 제어 블록

3.1.4 스레드

### 3.2   프로세스 스케줄링 123

3.2.1 스케줄링 큐

Linux의 프로세스 표현

3.2.2 CPU 스케줄링

3.2.3 문맥 교환

모바일 시스템에서의 다중 태스킹

### 3.3	프로세스에 대한 연산 128

3.3.1 프로세스 생성

init 와 systemd 프로세스

3.3.2 프로세스 종료

3.3.2.1 Android 프로세스 계층

### 3.4	프로세스간 통신 137

다중 프로세스 구조 - Chrome 브라우저

### 3.5	공유 메모리 시스템에서의 프로세스간 통신 139

### 3.6	메시지전달 시스템에서의 프로세스간 통신 141

3.6.1 명명

3.6.2 동기화

3.6.3 버퍼링

### 3.7	IPC 시스템의사례 146

3.7.1 POSIX 공유 메모리

3.7.2 Mach 메시지 전달

3.7.3 Windows

3.7.4 파이프

3.7.4.1 일반 파이프

3.7.4.2 지명 파이프

실제 상황에서의 파이프

### 3.8	클라이언트 서버 환경에서 통신 161

3.8.1 소켓

3.8.2 원격 프로시저 호출

3.8.2.1 Android RPC

## 스레드와 병행성

### 4.1	개요 176

4.1.1 동기

4.1.2 장점

4.2	다중 코어 프로그래밍 178

4.2.1 프로그래밍 도전과제

Amdahl’s Law

4.2.2 병렬 실행의 유형

4.3	다중 스레드 모델 182

4.3.1 다대일 모델

4.3.2 일대일 모델

4.3.3 다대다 모델

4.4	스레드 라이브러리 185

4.4.1 Pthreads

4.4.2 Windos 스레드

4.4.3 Java 스레드

Java에서의 Lambda 표현식

4.4.3.1 Java Executor 프레임워크

JVM과 호스트 운영체제

4.5	암묵적스레딩 194

4.5.1 스레드 풀

Android 스레드 풀

4.5.2 Fork Join

4.5.3 Open MP

4.5.4 Grand Central Dispatch

4.5.5 인텔 스레드 빌딩 블록

4.6	스레드와관련된문제들 206

4.6.1 Fork( ) 및 Exec( ) 시스템 콜

4.6.2 신호 처리

4.6.3 스레드 취소

4.6.4 스레드—로컬 저장장치

4.6.5 스케줄러 액티베이션

4.7	운영체제사례 213

4.7.1 Windows 스레드

4.7.2 Linux 스레드

## CPU 스케줄링

5.1	기본개념 220

5.1.1 CPU-I/O 버스트 사이클

5.1.2 CPU 스케줄러

5.1.3 선점 및 비선점 스케줄링

5.1.4 디스패처

5.2	스케줄링 기준 225

5.3	스케줄링 알고리즘 226

5.3.1 선입 선처리 스케줄링

5.3.2 최단 작업 우선 스케줄링

5.3.3 라운드 로빈 스케줄링

5.3.4 우선순위 스케줄링

5.3.5 다단계 큐 스케줄링

5.3.6 다단계 피드백 큐 스케줄링

5.4	스레드 스케줄링 239

5.4.1 경쟁 범위

5.4.2 Pthread 스케줄링

5.5	다중처리기스케줄링 242

5.5.1 다중 처리기 스케줄링에 대한 접근 방법

5.5.2 다중 코어 프로세서

5.5.3 부하 균등화

5.5.4 처리기 선호도

5.5.5 이기종 다중 처리

5.6	실시간 CPU 스케줄링 250

5.6.1 지연시간 최소화

5.6.2 우선순위 기반 스케줄링

5.6.3 Rate-Monotonic 스케줄링

5.6.4 Earliest-Deadline-First 스케줄링

5.6.5 일정 비율의 몫 스케줄링

5.6.6 POSIX 실시간 스케줄링

5.7	운영체제사례들 259

5.7.1 사례: Linux 스케줄링

CFS 성능

5.7.2 사레: Windows  스케줄링

5.7.3 시례: Solaris 스케줄링

5.8	알고리즘의 평가 268

5.8.1 결정론적 모델링

5.8.2 큐잉 모델

5.8.3 모의실험

5.8.4 구현

# 프로세스 동기화

## 동기화 도구들

6.1	배경 283

6.2	임계구역문제 286

6.3	Peterson의 해결안 288

6.4	동기화를위한하드웨어지원 291

6.4.1 메모리 장벽

6.4.2 하드웨어 명령어

compare_and_swap( ) 연산 원자적으로 만들기

6.4.3 원자적 변수

6.5	Mutex Locks 297

락 경합

“짧은 기간”이란 무엇을 의미하는가?

6.6	세마포 299

6.6.1 세마포 사용법

6.6.2 세마포 구현

6.7	모니터 303

6.7.1 모니터 사용법

6.7.2 세마포를 이용한 모니터의 구현

6.7.3 모니터 내에서 프로세스 수행 재개

6.8	라이브니스 310

6.8.1 교착상태

6.8.2 우선순위 역전

우선순위 역전과 Mars Pathfinder

6.9	평가 312

## 동기화 예제

7.1	고전적인동기화 문제들 319

7.1.1 유한 버퍼 문제

7.1.2 Readers-Writers 문제

7.1.3 식사하는 철학자들 문제

7.1.3.1 세마포 해결안

7.1.3.2 모니터 해결안

7.2	커널 안에서의 동기화 327

7.2.1 Windows의 동기화

7.2.2 Linux의 동기화

7.3	POSIX 동기화 330

7.3.1 POSIX mutex 락

7.3.2 POSIX 세마포

7.3.2.1 POSIX 기명 세마포

7.3.2.2 POSIX 무명 세마포

7.3.3 POSIX 조건 변수

7.4	Java에서의 동기화 334

7.4.1 Java 모니터

블록 동기화

7.4.2 재진입 락

7.4.3 세마포

7.4.4 조건 변수

7.5	대체방안들 342

7.5.1 트랜잭션 메모리

7.5.2 OpenMP

7.5.3 함수형 프로그래밍 언어

## 교착상태

8.1	시스템모델 350

8.2	다중 스레드 응용에서의 교착 상태 351

8.2.1 라이브락

8.3	교착 상태 특성 353

8.3.1 필요조건들

8.3.2 자원 할당 그래프

8.4	교착 상태 처리 방법 358

8.5	교착	상태	 예방	360

8.5.1 상호 배제

8.5.2 점유하며 대기

8.5.3 비선점

8.5.4 순환 대기

Linux LOCKDEP 도구

8.6	교착	상태 회피	363

8.6.1 안전 상태

8.6.2 자원 할당 그래프 알고리즘

8.6.3 은행원 알고리즘

8.6.3.1 안전성 알고리즘

8.6.3.2 자원 요청 알고리즘

8.6.3.3 예시

8.7	교착	상태	 탐지	371

8.7.1 각 자원 유형이 한 개씩 있는 경우

8.7.2 각 유형의 자원을 여러 개 가진 경우

JAVA THREAD DUMPS를 사용한 교착 상태 감지

8.7.1 탐지 알고리즘 사용

데이터베이스의 교착 상태 관리

8.8	교착	상태로부터 회복 376

8.8.1 프로세스와 스레드의 종료

8.8.2 자원 선점

# 메모리 관리

## 메인 메모리

9.1	배경 385

9.1.1 기본 하드웨어

9.1.2 주소의 할당

9.2	연속 메모리 할당 393

9.2.1 메모리 보호

9.2.1 메모리 할당

9.2.3 단편화

9.3	페이징 397

9.3.1 기본 방법

Linux 시스템에서 페이지 크기 알아내기

9.3.2 하드웨어 지원

9.3.2.1 Translation Look-Aside Buffer (TLB)

9.3.3 보호

9.3.4 공유 페이지

9.4	페이지 테이블의 구조 409

9.4.1 계층적 페이징

9.4.2 해시 페이지 테이블

9.4.3 역 페이지 테이블

9.4.4 Oracle SPARC Solaris

9.5	스와핑 414

9.5.1 기본 스와핑

9.5.2 페이징에서의 스와핑

9.5.3 모바일 시스템에서의 스와핑

스와핑에서의 시스템 성능

9.6	사례: Intel 32비트와 64비트구조 417

9.6.1 IA-32 구조

9.6.1.1 IA-32 세그먼테이션

9.6.1.2 IA-32 페이징

9.6.2 x86-64

64비트 컴퓨팅

9.7	사례: ARM 구조 421

## 가상 메모리

10.1	배경 428

10.2	요구페이징 431

10.2.1 기본 개념

10.2.2 가용 프레임 리스트

10.2.3 요구 페이징의 성능

10.3	쓰기 시 복사 438

10.4	페이지 교체 440

10.4.1 기본적인 페이지 교체

10.4.2 FIFO 페이지 교체

10.4.3 최적 페이지 교체

10.4.4 LRU 페이지 교체

10.4.5 LRU 근사 페이지 교체

10.4.5.1 부가적 참조 비트 알고리즘

10.4.5.2 2차 기회 알고리즘

10.4.5.3 개선된 2차 기회 알고리즘

10.4.6 개수—기반 페이지 교체

10.4.7 페이지—버퍼링 알고리즘

10.4.8 응용(applications)과 페이지 교체

10.5	프레임의 할당 454

10.5.1 최소로 할당해야 할 프레임의 수

10.5.2 할당 알고리즘

10.5.3 전역 대 지역 할당

주소 및 사소한 페이지 폴트

10.5.4 비균등 메모리 접근

10.6 스래싱 461

10.6.1 스레싱의 원인

10.6.2 작업 집합 모델

10.6.3 페이지 폴트 빈도

작업 집합과 페이지 폴트율

10.6.4 현재 관행

10.7	메모리 압축 467

10.8	커널 메모리의 할당 469

10.8.1 버디 시스템

10.8.2 슬랩 할당

10.9	기타 고려 사항 473

10.9.1 프리페이징

10.9.2 페이지 크기

10.9.3 TLB Reach

10.9.4 역 페이지 테이블

10.9.5 프로그램 구조

10.9.6 I/O 상호 잠금(I/O Interlock)과 페이지 잠금(locking)

10.10	운영체제의 예 480

10.10.1 Linux

10.10.2 Windows

10.10.2 Solaris

# 저장장치 관리

## 대용량 저장장치 구조

11.1	대용량 저장장치 구조의 개관 491

11.1.1 하드 디스크 드라이브

디스크 전송률

11.1.2 비휘발성 메모리 장치

11.1.2.1 비휘발성 메모리 장치 개요

11.1.2.2 NAND 플래시 컨트롤러 알고리즘

자가 테이프

11.1.3 휘발성 메모리

11.1.4 보조저장장치 연결 방법

11.1.5 주소 매핑

11.2	디스크 스케줄링 500

11.2.1 선입 선처리 스케줄링

11.2.2 SCAN 스케줄링

11.2.3 C-SCAN 스케줄링

11.2.4 디스크 스케줄링 알고리즘의 선택

11.3	NVM 스케줄링 504

11.4	오류 감지 및 수정 505

11.5	저장장치관리 506

11.5.1 드라이브 포메팅, 파티션, 볼륨

11.5.2 부트 블록

11.5.3 손상된 블록

11.6	스왑공간관리 511

11.6.1 스왑 공간 사용

11.6.2 스왑 공간 위치

11.6.3 스왑 공간 관리: 예

11.7	저장장치 연결 513

11.7.1 호스트 연결 저장장치

11.7.2 네트워크 연결 저장장치

11.7.3 클라우드 저장장치

11.7.4 SAN (Storage-Area Network)과 저장장치 배열(Storage Arrays)

11.8	RAID 구조 517

RAID  구성

11.8.1 중복으로 신뢰성 향상

11.8.2 병렬성을 이용한 성능 향상

11.8.3 RAID 레벨

11.8.4 RAID 레벨 선택

InServ 저장 배열

11.8.5 확장

11.8.6 RAID의 문제점들

11.8.7 객체 저장소

## 입출력 시스템

12.1	개관 535	

12.2	입출력 하드웨어 536	

12.2.1 메모리 맵드 입출력

12.2.2 폴링

12.2.3 인터럽트

12.2.4 직접 메모리 접근

12.2.5 입출력 하드웨어 요약

12.3	응용 입출력 인터페이스	548

12.3.1 블록 장치와 문자 장치

12.3.2 네트워크 장치

12.3.3 클록과 타이머

12.3.4 봉쇄형과 비봉쇄형 입출력

12.3.5 벡터형 입출력

12.4	커널 입출력 서브시스템	556

12.4.1 I/O 스케줄링

12.4.2 버퍼링

12.4.3 캐싱

12.4.4 스풀링 및 장치 예약

12.4.5 오류 처리

12.4.6 입출력 보호

12.4.7 커널 자료구조

12.4.8 전원 관리

12.4.9 커널 입출력 서브시스템 요약

12.5	입출력 요구를 하드웨어 연산으로 변환	

12.6	STREAMS 568	

12.7	성능 570

# 파일 시스템

## 파일 시스템 인터페이스

13.1	파일 개념 579

13.1.1 파일 속성

13.1.2 파일 연산

Java에서 파일 락킹(File locking)

13.1.3 파일 유형

13.1.4 파일 구조

13.1.5 파일의 내부 구조

13.2	접근방법 590

13.2.1 순차 접근

13.2.2 직접 접근

13.2.3 기타 접근 방법

13.3	디렉터리구조 593

13.3.1 1단계 디렉터리

13.3.2 2단계 디렉터리

13.3.3 트리 구조 디렉터리

13.3.4 비순환 그래프 디렉터리

13.3.5 일반 그래프 디렉터리

13.4	보호 603

13.4.1 접근의 유형

13.4.2 접근 제어

UNIX 시스템에서 권한들

13.4.3 다른 보호 방법

13.5	메모리 사상 파일 608

13.5.1 기본 기법

13.5.2 Windows API에서 공유 메모리

## 파일 시스템 구현

14.1	파일 시스템 구조 618

14.2	파일 시스템 구현 620

14.2.1 개요

14.2.2 사용법

14.3	디렉터리구현 623

14.3.1 선형 리스트

14.3.2 해시 테이블

14.4	할당방법 625

14.4.1 연속 할당

14.4.2 연결 할당

14.4.3 색인 할당

14.4.4 성능

14.5	가용공간의관리 634

14.5.1 비트 벡터

14.5.2 연결 리스트

14.5.3 그룹핑

14.5.4 계수

14.5.5 공간맵

14.5.6 사용하지 않는 블록 트림

14.6	효율과성능 637

14.6.1 효율

14.6.2 성능

14.7	복구 642

14.7.1 일관성 검사

14.7.2 로그 구조 파일 시스템

14.7.3 다른 해결 방안들

14.7.4 백업과 복구

14.8	예: WAFL 파일 시스템 646

Apple 파일 시스템

## 파일 시스템 내부구조

15.1	파일 시스템 655

15.2	파일시스템마운팅 657

15.3	파티션과마운팅 659

15.4	파일공유 660

15.4.1 다수의 사용자

15.5	가상 파일 시스템 662

15.6	원격 파일 시스템 664

15.6.1 클라이언트 서버 모델

15.6.2 분산 정보 시스템

15.6.3 고장 모드

15.7	일관성의 의미 668

15.7.1 UNIX의 의미

15.7.2 세션 의미

15.7.3 불변 공유 파일의 의미

15.8	NFS 669

15.8.1 개요

15.8.2 마운트 프로토콜

15.8.3 NFS 프로토콜

15.8.4 경로 이름 반환

15.8.5 원격 연산

# 보안과 보호

## 보안

16.1	보안문제 681

16.2	프로그램 위협 685

16.2.1 악성 코드

최소 권한의 원칙

16.2.2 코드 주입

16.2.3 바이러스와 웜

16.3	시스템과 네트워크 위협

16.3.1 네트워크 트래픽 공격

16.3.2 서비스 거부

16.3.3 포트 스캐닝

16.4	보안 도구로서 암호 기법

16.4.1 암호화

16.4.1.1 대칭 암호화

16.4.1.2 비대칭 암호화

16.4.1.3 인증

16.4.1.4 키 문제

16.4.2 암호의 구현

16.4.3 예: TLS

16.5	사용자인증 712

16.5.1 패스워드

16.5.2 패스워드 취약점

16.5.3 패스워드의 안전

강력하고 기억하기 쉬운 암호

16.5.4 일회용 패스워드

16.5.5 생체 측정

16.6	보안방어의구현 717

16.6.1 보안 정책

16.6.2 취약점 평가

16.6.3 침입 방지

16.6.4 바이러스 보호

16.6.5 감사, 회계 및 로깅

16.6.6 방화벽을 이용한 시스템과 네트워크 보호

16.6.7 기타 솔루션

16.6.8 보안 방어 요약

16.7	예: Windows 10 727

## 보호

17.1	보호의 목표 733	

17.2	보호의 원칙 734	

17.3	보호링 735	

17.4	보호의 영역 738	

17.4.1 영역 구조

17.4.2 예: UNIX

17.4.3 예: Android 응용 프로그램 ID

17.5	접근행렬 742	

17.6	접근 행렬의 구현	746

17.6.1 전역 테이블

17.6.2 객체를 위한 접근 리스트

17.6.3 영역을 위한 자격 리스트

17.6.4 락—키 기법

17.6.5 비교

17.7	접근 권한의 취소	749

17.8	역할 기반 액세스 제어	751

17.9	강제적 접근 제어	752

17.10	자격-기반 시스템	753

17.10.1 Linux 자격

17.10.2 Darwin 자격

17.11	기타보호개선 방법 755	

17.11.1 시스템 무결성 보호

17.11.2 시스템 콜 필터링

17.11.3 샌드박싱

17.11.4 코드 서명

17.12	언어 기반의 보호	758

17.12.1 컴파일러 기반 시행

17.12.2 컴파일러 기반 시행—자바의 보호

# 진보된 주제

## 가상 머신

18.1	개요 769

18.2	역사 771

18.3	장점 및 특징 772

18.4	빌딩블록 775

18.4.1 트랩—앤—에뮬레이트

18.4.2 이진 변환

18.4.3 하드웨어 지원

18.5	VM 유형 및 구현 781

18.5.1 가상 머신 수명 주기

18.5.2 유형 0 하이퍼바이저

18.5.3 유형 1 하이퍼바이저

18.5.4 유형 2 하이퍼바이저

18.5.5 반 가상화

18.5.6 프로그래밍 환경 가상화

18.5.7 에뮬레이션

18.5.8 응용 프로그램 격리

18.6	가상화와 운영체제구성요소 789

18.6.1 CPU 스케줄링

18.6.2 메모리 관리

18.6.3 I/O

18.6.4 스토리지 관리

18.6.5 실시간 마이그레이션

18.7	사례 796

18.7.1 VMware

18.7.2 Java 가상 머신

18.8	가상화연구 798

## 네트워크 및 분산 시스템

19.1	분산시스템의장점 803

19.1.1 자원 공유

19.1.2 계산 속도 향상

19.1.3 신뢰성

19.2	네트워크구조 805

19.2.1 로컬 영역 네트워크

19.2.2 광역 네트워크

19.3	통신구조 808

19.3.1 이름 지정 및 이름 찾기

19.3.2 통신 프로토콜

19.3.3 TCP/IP 예

19.3.4 전송 프로토콜 UDP 및 TCP

19.3.4.1 User Daiagram Protocol

19.3.4.2 Transmission Control Protocol

19.4	네트워크및 분산 운영체제 820

19.4.1 네트워크 운영체제

19.4.1.1 원격 로그인

19.4.1.2 원격 파일 전송

19.4.1.3 클라우드 저장장치

19.4.2 분산 운영체제

19.4.2.1 데이터 마이그레이션

19.4.2.2 계산 마이그레이션

19.4.2.3 프로세스 마이그레이션

19.5	분산 시스템의 설계 문제 824

19.5.1 견고성

19.5.1.1 장애 감지

19.5.1.2 재구성

19.5.1.3 장애 복구

19.5.2 투명성

19.5.3 확장성

19.6	분산 파일 시스템 829

19.6.1 클라이언트-서버 DFS 모델

19.6.2 클러스터 기반 DFS 모델

19.7	DFS 명명 및 투명성 833

19.7.1 명명 구조

19.7.2 명명 기법

19.7.3 구현 기법

19.8	원격 파일 액세스 836

19.8.1 기본 캐싱 기법

19.8.2 캐시 위치

19.8.3 캐시 업데이트 정책

19.8.4 일관성

19.9	분산 파일 시스템에 대한 최종 생각 840

# 사례 검토

## Linux 시스템

20.1	Linux 역사 847

20.1.1 Linux 커널

20.1.2 Linux 시스템

20.1.3 Linux 배포본

20.1.4 Linux 저작권

20.2	설계 원칙 853

20.2.1 Linux 시스템의 구성요소

20.3	커널모듈 856

20.3.1 모듈 관리

20.3.2 드라이버 등록

20.3.3 충돌 해결

20.4	프로세스 관리 860

20.4.1 fork( )/exec( ) 프로세스 모델

20.4.1.1 프로세스 식별

20.4.1.2 프로세스 환경

20.4.1.3 프로세스 문맥

20.4.2 프로세스와 스레드

20.5	스케줄링 864

20.5.1 스레드 스케줄링

20.5.2 실시간 스케줄링

20.5.3 커널 동기화

20.5.4 대칭형 다중 처리

20.6	메모리 관리 870

20.6.1 물리 메모리의 관리

20.6.2 가상 메모리

20.6.2.1 가상 메모리 영역

20.6.2.2 가상 주소 공간의 일생

20.6.2.3 스와핑과 페이징

20.6.2.4 커널 가상 메모리

20.6.3 사용자 프로그램의 로딩과 실행

20.6.3.1 프로그램을 메모리로 매핑

20.6.3.2 정적 링킹과 동적 링킹

20.7	파일 시스템 880

20.7.1 가상 파일 시스템

20.7.2 Linux ext3 파일 시스템

20.7.3 저널링

20.7.4 Linux 프로세스 파일 시스템

20.8	입/출력 887

20.8.1 블록 장치

20.8.2 문자 장치

20.9	프로세스간 통신 890

20.9.1 동기화와 신호

20.9.2 프로세스들 사이의 데이터 전달

20.10	네트워크구조 891

20.11	보안 894

20.11.1 인증

20.11.2 접근 제어

## 윈도우 10

21.1	역사 901

21.1.1 Windows XP, Vista, and 7

21.1.2 Windows 8

21.1.3 Windows 10

21.2	설계 원칙 906

21.2.1 보안

21.2.2 안정성

21.2.3 Windows 및 응용 호환

21.2.4 높은 성능

21.2.5 확장성

21.2.6 이식성

21.2.7 국제화 지원

21.2.8 에너지 효율

21.2.9 동적 장치 지원

21.3	시스템 구성요소 920

21.3.1 Hyper-V 하이퍼바이저

21.3.2 보안 커널

21.3.3 하드웨어 추상 층

21.3.4 커널

21.3.4.1 디스패처

21.3.4.2 사용자 모드와 커널 모드 스레드 간 전환

21.3.4.3 스레드

21.3.4.4 스레드 스케줄링

21.3.4.5 동기화 프리미티브의 구현

21.3.4.6 인터럽트 요청 수준(IRQL)

21.3.4.7 소프트웨어 인터럽트: 비동기 및 지연된 프로시저 호출

21.3.4.8 예외와 인터럽트

21.3.5 Executive

21.3.5.1 객체 관리자

21.3.5.2 가상 메모리 관리자

21.3.5.3 프로세스 관리자

21.3.5.4 클라이언트—서버 컴퓨팅을 지원하는 설비

21.3.5.5 입출력 관리자

21.3.5.6 캐시 관리자

21.3.5.7 보안 참조 모니터

21.3.5.8 플러그 앤드 플레이 관리자

21.3.5.9 전원 관리자

21.3.5.10 레지스트리

21.3.5.11 부팅

21.4	터미널 서비스와 빠른 사용자 교체 960

21.5	파일 시스템 961

21.5.1 NTFS 내부 배치

21.5.1.1 NTFS B+ 트리

21.5.1.2 NTFS 메타데이터

21.5.2 복구

21.5.3 보안

21.5.4 압축

21.5.5 마운트 포인트, 심볼릭 링크 및 경성 링크

21.5.6 변경 저널

21.5.7 볼륨 섀도 복사본

21.6	네트워킹 968

21.6.1 네트워크 인터페이스

21.6.2 프로토콜

21.6.2.1 서버 메세지 블록

21.6.2.2 TCP/IP

21.6.2.3 점대점 터널링 프로토콜

21.6.2.4 HTTP 프로토콜

21.6.2.5 웹 분산 저작 및 버전 부여 프로토콜

21.6.2.6 지명 파이프

21.6.2.7 원격 프로시저 호출

21.6.2.8 공통 객체 모델

21.6.3 방향 재지정자와 서버

21.6.3.1 분산 파일 시스템

21.6.3.2 폴더 방향 재지정과 클라이언트측 캐싱

21.6.4 도메인

21.6.5 활성 디렉터리

21.7	프로그래머 인터페이스 973

21.7.1 커널 캑체로의 접근

21.7.2 프로세스 간의 객체 공유

21.7.3 프로세스 관리

21.7.3.1 스케줄링 규칙

21.7.3.2 스레드 우선순위

21.7.3.3 스레드 보류와 재개

21.7.3.4 스레드 동기화

21.7.3.5 스레드 풀

21.7.3.6 파이버

21.7.3.7 사용자 모드 스케줄링과 ConcRT

21.7.3.8 Winsock

21.7.4 Windows 메시징을 사용한 프로세스 간 통신

21.7.5 메모리 관리

21.7.5.1 가상 메모리

21.7.5.2 메모리 맵드 파일

21.7.5.3 힙

21.7.5.4 스레드-로컬 저장장치

21.7.5.5 AWE 메모리

# 부록

## 영향력 있는 운영체제

A.1 기능전이 991
A.2 초기 시스템 992
A.3 Atlas 1000
A.4 XDS-940 1001
A.5 THE 1002
A.6 RC 4000 1002
A.7 CTSS 1004
A.8 MULTICS 1004
A.9 IBM OS/360 1005
A.10 TOPS-20 1006
A.ll CP/M과 MS/DOS 1007
A.12 Macintosh 운영체제와 Windows 1008
A.13 Mach 1008
A.14 자격-기반 시스템ㅡHydra 및 CAP 1010
A.15 기타시스템들 1013

Appendix B, C, D와 Additional excercises는 퍼스트북 홈페이지 ㅡ> 자료실 데이터파일에 올려 놓았으며, 아래 사이트에 접속하시면 확인하실 수 있습니다.
[http://firstbook.kr/](http://firstbook.kr/)
