---
layout: page
title: 마이크로 커널
parent: 커널
---

### 정의
이 방법은 모든 중요치 않은 구성요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다.

결과는 더 작은 커널이다.

어느 서비스가 커널에 남아 있어야 하고, 어느 사버시가 사용자 공간에 구현되어야 할지에 대해서는 의견이 일치하지 않는다.

그러나 통상 마이크로커널은 통신 설비 외에 추가로 최소한의 프로세스와 메모리 관리를 제공한다.

![image](https://github.com/yokikim/osdinostudy_1/blob/main/os_pic/2.15.png?raw=true)

### 주 기능

마이크로 커널의 주 기능은 클라이언트 프로그램과 역시 사용자 공간에서 수행되는 다양한 서비스 간에 통신을 제공하는 것이다.

통신은 시스템 콜의 통신 기능 중 메시지 전달에 의해 제공된다.

> 예를 들면, 만일 클라이언트 프로그램이 파일에 접근하기를 원하면, 파일 서버와 반드시 상호 작용해야 한다.
> 
> 클라이언트 프로그램과 서비스는 결코 직접 상호 작용하지 않는다.
> 
> 오히려, 그들은 마이크로 커널과 메세지를 교환함으로써 간접적으로 상호작용한다.

### 장점

마이크로커널 접근법의 한 가지 장점은 운영체제의 확징이 쉽다는 것이다.

모든 새로운 서비스는 사용자 공간에 추가되며, 따라서 커널을 변경할 필요 없다.

커널이 변경되어야만 할 때는, 마이크로커널이 작은 커널이기 때문에 변경할 대상이 비교적 적은 경향이 있다.

결과적으로 만들어지는 운영체제는 한 하드웨어로부터 다른 하드웨어로 이식이 쉽다.

마이크로커널은 서비스 대부분이 커널이 아니라 사용자 프로세스로 수행되기 때문에 또한 더욱 높은 보안성과 신뢰성을 제공한다.

만일 한 서비스가 잘못되더라도, 운영체제의 다른 부분은 아무런 영향을 받지 않는다.

### 예시

마이크로커널 운영체제의 가장 잘 알려진 실례는 macOS 및 iOS 운영체제의 커널 구성요소는 ***Darwin***이다.

실제로 Darwin은 두 개의 커널로 구성되며 그 중 하나는 Mach 마이크로커널이다.

또 다른 예는 실시간 운영체제인  QNX이다.

QNX Neutrio 마이크로커널은 메세지 전달과 프로세스 스케줄링을 위한 서비스를 제공한다.

QNX는 또한 저수준의 네트워크 통신과 하드웨어 인터럽트를 처리한다.

QNX의 다른 모든 서비스는 사용자 모드로 커널 밖에서 수행되는 표준 프로세스들에 의해 제공된다.

### 단점

안타깝게도 마이크로커널은 가중된 시스템 기능 오베헤드 때문에 성능이 나빠진다.

두 개의 사용자 수준 서비스가 통신해야 하는 경우 별도의 주소 공간에 서비스가 존재하기 때문에 메세지가 복사되어야 한다.

또한 운영체제는 메세지를 교환하기 위해 한 프로세스에서 다음 프로세스로 전환해야 할 수도 있다.

메세지 복사 및 프로세스 전환과 관련된 오버헤드는 마이크로커널 기반 운영체제의 성장에 가장 큰 장애였다.

Windows NT의 역사를 고려해보자.

첫 번째 릴리스에는 계층화된 마이크로커널 구조였다.

이 버전의 성능은 Windows 95에 비해서도 성능이 떨어졌다.

Windows NT 4.0은 계층들을 사용자 공간으로부터 커널 공간으로 옮기고 그들을 더욱 긴밀히 통합함으로써 성능문제를 부분적으로 개선하였다.

Windows XP가 설계될 때 까지 Windows 구조는 마이크로커널 보다는 모놀리식에 가까운 구조였다.