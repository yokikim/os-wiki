8p

일반적인 컴퓨터 작업(입출력을 수행하는 프로그램)을 고려하자. 입출력 작업을 시작하기 위해 장치 드라이버는 장치 컨트롤러의 적절한 레지스터에 값을 적재한다.
그런 다음 장치 컨트롤러는 이러한 레지스터의 내용을 검사하여 수행할 작업을(예: "키보드에서 문자 읽기") 결정한다.
컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작한다.
데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었음을 알린다.
그런 다음 장치 드라이버는 읽기 요청이면 데이터 또는 데이터에 대한 포인터를 반환하며 운영체제의 다른 부분에 제어를 넘긴다. 다른 작업의 경우 장치 드라이버는 "쓰기 완료" 또는 "장치 사용 중" 과 같은 상태 정보를 반환한다.

그러나 컨트롤러는 장치 드라이버에게 작업을 완료했다는 사실을 어떻게 알리는가? 이는 인터럽트를 통해 이루어진다.


***

540p

대부분 컴퓨터 구조에서는 한 장치를 폴하기 위해 세 개의 [[CPU]] 명령 사이클로 충분하다.
즉, 장치 [[레지스터]]를 읽고, 상태 비트를 추출하기 위해 논리곱(logicaland)을 하고, 0이 아니면 분기(branch)한다.
분명히 기본 [[폴링]] 연산을 효율적이다.
그라너 호스트가 폴링을 반복하고 있짐나 장치가 서비스할 준비가 되는 데에 시간이 오래 걸린다면, [[폴링]]은 비효율적 연산이 되고, 다른 유용한 CPU 처리가 계속 지연된다.
이와 같은 경우에는 하드웨어 컨트롤러가 자신의 상태가 바뀔 때 CPU에 그것을 통보해 주는 것이 반복적으로 폴링을 하는 것보다 더욱더 효율적이다.

입출력 장치가 [[CPU]]에 자신의 상태 변화를 통보하는 하드웨어 기법을 인터럽트(interrupt)라고 한다.

***

[[트랩]]

[[시스템 콜]]